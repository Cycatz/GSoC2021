#+TITLE: Final Report 
#+LATEX_HEADER: \def\mytitle{Final Report}
#+AUTHOR: Fan Chung
#+LATEX_CLASS: org-plain-latex
#+LATEX_CLASS_OPTIONS: [letterpaper, 11pt]
#+LATEX_HEADER: \usepackage[T1]{fontenc} % set encoding? need survey
#+LATEX_HEADER: \usepackage[utf8]{inputenc} % force utf8 encoding

#+LATEX_HEADER: \usepackage{graphicx} % Enhanced support for graphics
#+LATEX_HEADER: \usepackage{amsmath, amsthm, amssymb} % Provides mathematical facilities/enhancments
#+LATEX_HEADER: \usepackage[table, xcdraw]{xcolor} % Extends Latex's color facilities 
#+LATEX_HEADER: \usepackage{mathtools}


#+LATEX_HEADER: \usepackage{geometry}
#+LATEX_HEADER: \geometry{top=1in, bottom=1.25in, left=1.25in, right=1.25in}


#+LATEX_HEADER: \usepackage{fontspec}
#+LATEX_HEADER: \setmonofont{Inconsolata}



#+LATEX_HEADER: \definecolor{bblue}{HTML}{0645AD}
#+LATEX_HEADER: \usepackage{hyperref}
#+LATEX_HEADER: \hypersetup{colorlinks, linkcolor=black, urlcolor=bblue}


#+LATEX_HEADER: \usepackage[space]{xeCJK}
#+LATEX_HEADER: \setCJKmainfont{Noto Sans CJK TC}[UprightFont = {*-Regular}, BoldFont = {*-Bold}]
#+LATEX_HEADER: \linespread{1.1}\selectfont        % 行距
#+LATEX_HEADER: \XeTeXlinebreaklocale "zh"         % 針對中文自動換行，因為英文只會在空白處斷行，中文可以任意
#+LATEX_HEADER: \XeTeXlinebreakskip = 0pt plus 1pt % 字與字之間加入0pt至1pt的間距，確保左右對整齊
#+LATEX_HEADER: \parindent 0em                     % 段落縮進
#+LATEX_HEADER: \setlength{\parskip}{8pt}         % 段落之間的距離


#+LATEX_HEADER: \usepackage{fancyhdr} % Provides options for configuring footer and header
#+LATEX_HEADER: \pagestyle{fancy}
#+LATEX_HEADER: \ifdefined\mytitle
#+LATEX_HEADER:     \fancyhead{}
#+LATEX_HEADER:     \chead{\mytitle}
#+LATEX_HEADER: \fi
#+LATEX_HEADER: \renewcommand{\headrulewidth}{0.4pt}




#+LATEX_HEADER: \renewcommand{\href}[2]{#2\footnote{\url{#1}}}


#+LATEX_HEADER: \usepackage[titles]{tocloft}
#+LATEX_HEADER: \setlength{\cftbeforesecskip}{3pt}


#+LATEX_HEADER: \usepackage{paralist}
#+LATEX_HEADER:   \let\itemize\compactitem
#+LATEX_HEADER:   \let\enditemize\endcompactitem
#+LATEX_HEADER:   \let\enumerate\compactenum
#+LATEX_HEADER:   \let\endenumerate\endcompactenum
#+LATEX_HEADER:   \let\description\compactdesc
#+LATEX_HEADER:   \let\enddescription\endcompactdesc
#+LATEX_HEADER:   \pltopsep=1pt
#+LATEX_HEADER:   \plitemsep=1pt
#+LATEX_HEADER:   \plparsep=1pt


#+LATEX_HEADER: \renewcommand\labelitemii{$\circ$}


#+LATEX_HEADER: \usepackage{titling}
#+LATEX_HEADER: \setlength{\droptitle}{-6em}



#+LATEX_HEADER: \usepackage[explicit]{titlesec}
#+LATEX_HEADER: \pretitle{\begin{center}\fontsize{20pt}{20pt}\selectfont}
#+LATEX_HEADER: \posttitle{\par\end{center}}
#+LATEX_HEADER: \preauthor{\begin{center}\vspace{-6bp}\fontsize{14pt}{14pt}\selectfont}
#+LATEX_HEADER: \postauthor{\par\end{center}\vspace{-25bp}}

#+LATEX_HEADER: \predate{\begin{center}\fontsize{12pt}{12pt}\selectfont}
#+LATEX_HEADER: \postdate{\par\end{center}\vspace{0em}}


#+LATEX_HEADER: \titlespacing{\section}{0pt}{5pt}{-5pt} % left margin, space before section header, space after section header
#+LATEX_HEADER: \titlespacing{\subsection}{0pt}{5pt}{-5pt} % left margin, space before subsection header, space after subsection header
#+LATEX_HEADER: \titlespacing{\subsubsection}{0pt}{5pt}{-5pt} % left margin, space before subsection header, space after subsection header 


# TODO 時態要一致= =

* Introduction to ~vt(4)~

** What is ~vt(4)~?
According to man page ~vt(4)~, vt is a /virtual terminal console driver/, and it provides multiple virtual terminals with an extensive feature set.

For example:
+ Unicode UTF-8 text with double-width characters.
+ Large font maps in graphics mode, including support for Asian character sets.
+ Graphics-mode consoles.
+ Integration with KMS (Kernel Mode Setting) video drivers for switching between the X Window System and virtual terminals.


** ~vt(4)~ in Kernel
The kernel sources of ~vt~ are located under ~src/sys/dev/vt~. The ~vt~ component including the following main files:
# How to describe the display buffer? frame buffer I think...? 
# Does hw/ contains different "hardware", if so, how to explain "fb"? 
+ ~hw/~: contain the frame buffer implementations for different hardware drivers, such as ~vga~, ~fb~.
+ ~logo/~: for storing cpu logos pixel data. (~logo_beastie.c~ and ~logo_freebsd.c~)
+ ~font/~: for storing the default font and mouse cursor pixel data.
+ ~color/~: for customizing color palette entries. (set with ~kern.vt.color.<colornum>.rgb~)
+ ~vt.h~: the main header file, containing struct/function declarations of sources.
+ ~vt_core.c~: the main source file, containing instances of structures and APIs
+ ~vt_buf.c~: for accessing and manipulating console data buffer.
+ ~vt_font.c~: for loading fonts when the graphic mode is set.
+ ~vt_cpulogos.c~: for drawing cpu logos during booting.
+ ~vt_sysmouse.c~: for defining virtual mouse device driver ~sysmouse(4)~
+ ~vt_consolectl.c~: ?

** Digging into ~vt(4)~

But you might ask the questions like:
+ How to understand the so-called /console driver/?
+ Is it a console or a driver?
+ What are requirements for becoming a console driver?

Don't worry! In this section, we will explore the internal of ~vt~ and introduce what they do and how they work. Let's go!

To understand ~vt~ more easily, you can imagine ~vt~ is a regular terminal emulator application, for example, ~xterm~. The only difference between them is ~vt~ lies in kernel, that is, its components you interact with work in a low-level way.

For any terminal emulator, you can type commands on it, and it will show you the results. Or you can move the mouse to copy/paste some text and scoll the mouse wheel to navigate between history. Moreover, you can use control sequences to move the cursor, changes screen colors and etc. ~vt~ has no exception. In general, the features mentioned above corresponds to three main components of ~vt~: input, output and termianl features.

# ~vt~ can be divide into three parts: input, output and terminal features.

*** Input 
**** Keyboard  
The keyboard part is  


**** Mouse  

With a mouse, one can copy and paste text from the screen in ~vt~.

The mouse feature in ~vt~ is implemented with ~sysmouse(4)~, a virtualized mouse driver.

Quoted from ~sysmouse(4)~
#+begin_quote
The console driver, in conjunction	with the mouse daemon moused(8), sup-
plies mouse data to the user process in the standardized way via the
sysmouse driver.  This arrangement	makes it possible for the console and
the user process (such as the X Window System) to share the mouse.
#+end_quote


The following code snippet shows the function ~sysmouse_drvinit()~ creates a device called ~/dev/sysmouse~. Note that the ~SYSINIT~ in the last line do ~sysmouse~ driver initalization. 

#+begin_src c
/*  sys/dev/vt/vt_sysmouse.c:477 */  
static void
sysmouse_drvinit(void *unused)
{

	if (!vty_enabled(VTY_VT))
		return;
	mtx_init(&sysmouse_lock, "sysmouse", NULL, MTX_DEF);
	cv_init(&sysmouse_sleep, "sysmrd");
	make_dev(&sysmouse_cdevsw, 0, UID_ROOT, GID_WHEEL, 0600,
	    "sysmouse");
#ifdef EVDEV_SUPPORT
	sysmouse_evdev_init();
#endif
}

SYSINIT(sysmouse, SI_SUB_DRIVERS, SI_ORDER_MIDDLE, sysmouse_drvinit, NULL);
#+end_src


The following code snippet shows the non-static function ~sysmouse_process_event()~ fires up ~vt_mouse_event()~ and pass the mouse infomation.

#+begin_src c 
/* sys/dev/vt/vt_sysmouse.c:202 */
void
sysmouse_process_event(mouse_info_t *mi)
{
    /* ... */

    #ifndef SC_NO_CUTPASTE
    mtx_unlock(&sysmouse_lock);
    vt_mouse_event(mi->operation, x, y, mi->u.event.id, mi->u.event.value,
        sysmouse_level);
    return;
    #endif
#+end_src


And the function ~sysmouse_process_event()~ is invoked by ~consolectl_ioctl()~ in ~vt_consolectl.c~. Everything seems so reasonable!    
#+begin_src c
/* src/sys/dev/vt/vt_consolectl.c:50 */
static int
consolectl_ioctl(struct cdev *dev, u_long cmd, caddr_t data, int flag,
    struct thread *td)
{
    /* ... */

    case CONS_MOUSECTL: {
        mouse_info_t *mi = (mouse_info_t*)data;

        sysmouse_process_event(mi);
        return (0);
    }
#+end_src



Finally, depending on different mouse actions and events, ~vt_mouse_event()~ will do corresponding behaviors on the screen such as marking, copying, pasting and etc. 

You may refer to ~sys/dev/vt/vt_core.c:2136~ for more details.

*** Output 
~vt~ provides sereval hardware backends 

*** Terminal Features 

#+begin_src c 
/* sys/dev/vt/vt_core.c:90 */
const struct terminal_class vt_termclass = {
  .tc_bell = vtterm_bell,
  .tc_cursor = vtterm_cursor,
  .tc_putchar = vtterm_putchar,
  .tc_fill = vtterm_fill,
  .tc_copy = vtterm_copy,
  .tc_pre_input = vtterm_pre_input,
  .tc_post_input = vtterm_post_input,
  .tc_param = vtterm_param,
  .tc_done = vtterm_done,

  .tc_cnprobe = vtterm_cnprobe,
  .tc_cngetc = vtterm_cngetc,

  .tc_cngrab = vtterm_cngrab,
  .tc_cnungrab = vtterm_cnungrab,

  .tc_opened = vtterm_opened,
  .tc_ioctl = vtterm_ioctl,
  .tc_mmap = vtterm_mmap,
};
#+end_src

* My works

** Introduction 
As the proposal stated, this project aims to provide an environment that can run IME (input method engine) to enable users to type CJK characters in ~vt~.    

This project was divided into two parts, backend and frontend. The backend is supposed to process keys sent from the frontend and translate them into valid CJK characters, depending on different input schemas. The frontend, on the other hand, recieves utf-8 encoded CJK characters and insert them on the screen. Additionally, the frontend need to print preedit string and candidates during composing.

** Backend
To facilitate the software development process, I choose /Python/ as our backend developmemt language. Compared with other programming languages, /Python/ is renowned for its easy-to-use APIs as well as being an interpreted language. 
 
I started by implementing FFI between C and Python with /ctypes/ to access C APIs provided in /librime/. However, I found it's difficult to fully implement the mappings from /librime/'s structs and functions to /Python/'s own data types. As a result, I decided to add a C wrapper to define my custom data members and methods to encapsulate those /librime/'s APIs and compiled it into a shared library to be loaded with /ctypes/. Thus I can use Python to write the backend. The code of this part can be found in the directory [[https://gitlab.com/Cycatz/tmux-rime/-/tree/main/tmux_rime][~tmux_rime/rime_wrapper~]] in previously listed ~tmux-rime~ repository. 


The next step is to consider how to accomplish the communication between the frontend and backend. The frontend needs to recieve keys from the user, then waits for the backend sending the results back. However, you never know when a user will finish composing. For example, if a user presses a single key ~'5'~ on a standard QWERTY keyboard, which is mapped to a [[https://zh.wikipedia.org/w/index.php?title=%E8%81%B2%E6%AF%8D&redirect=no][/initial/]] (/聲母/ in chinese) 「ㄓ」 (chih in /Wade–Giles/ romanization) in the input schema [[https://en.wikipedia.org/wiki/Bopomofo][/Bopomofo/]] , the IME server can't decide whether there still have key sequences or not, since the user can continue to press the keys mapped to [[https://en.wikipedia.org/wiki/Four_tones_(Middle_Chinese)][Four tones,]] such as pressing the key '3' to compose 「ㄓˇ」 or the space key to compose 「ㄓ」 with /even/ (平 píng) tone. Therefore, the backend IME server is required to keep running in background for listening requests from the frontend. I wrote server-side code with Python's ~socketserver~. You may refer to [[https://gitlab.com/Cycatz/tmux-rime/-/blob/main/tmux_rime/tmux_rime_server.py][~tmux_rime/rime_wrapper/tmux_rime_server.py~]]

Before implementing the frontend in ~vt~, I implemented the frontend for ~tmux~ for the GSoC first stage evaluation as a proof of concept. It also serves as a test ground for the backend and /librime/. The following figures shows the structure and the screenshot of ~tmux-rime~.

#+ATTR_LATEX: :width 4in 
#+CAPTION: tmux-rime structure
[[file:assets/tmux-rime_structure.png]]  
  
#+ATTR_LATEX: :width 6in 
#+CAPTION: tmux-rime screenshot
[[file:assets/tmux-rime_screenshot.png]]

\clearpage 

** Frontend 

# FIX The sentence is too loooooooong~   
The two most important functions associated with the frontend implementation are ~vt_processkey~ and ~terminal_input_char~. The former is for processing the key, and the latter is for inserting text onto the screen. Therefore, I hijacked the ~vt_processkey~ function. Instead of directly outputting text onto the screen with ~terminal_input_char~ function, I defined a new function called ~vt_ime_process_char~ to handle the user input then send requests to the IME server to convert them into CJK characters when the IME mode is enabled.       

#+begin_src diff
@@ -991,9 +1013,16 @@ vt_processkey(keyboard_t *kbd, struct vt_device *vd, int c)
+ #if VT_IME
+             if (vt_ime_is_enabled(&vt_ime_default))
+                 vt_ime_process_char(vw->vw_terminal, main_vd, &vt_ime_default, KEYCHAR(c));
+             else
+ #endif
                terminal_input_char(vw->vw_terminal, KEYCHAR(c));
#+end_src


#+begin_src diff 
@@ -212,6 +218,10 @@ struct vt_buf {
        term_rect_t              vb_dirtyrect;  /* (b) Dirty rectangle. */
        term_char_t             *vb_buffer;     /* (u) Data buffer. */
        term_char_t             **vb_rows;      /* (u) Array of rows */
+
+#ifdef VT_IME
+       term_char_t             *vb_ime_buffer; /* (u) IME status bar buffer. */
+#endif
 };
#+end_src

#+begin_src diff
@@ -257,8 +267,20 @@ void vtbuf_extract_marked(struct vt_buf *vb, term_char_t *buf, int sz);
        ((vb)->vb_history_size)
 #define        VTBUF_GET_ROW(vb, r) \
        ((vb)->vb_rows[((vb)->vb_roffset + (r)) % VTBUF_MAX_HEIGHT(vb)])
-#define        VTBUF_GET_FIELD(vb, r, c) \
+
+#ifdef VT_IME
+#define VTBUF_GET_FIELD(vb, r, c) \
        ((vb)->vb_rows[((vb)->vb_roffset + (r)) % VTBUF_MAX_HEIGHT(vb)][(c)])
+#else
+inline term_char_t VTBUF_GET_FIELD(const struct vt_buf *vb, int r, int c)
+{
+    if (vt_test && r == 0) {
+        return vb->vb_ime_buffer[c];
+    } else {
+        return ((vb)->vb_rows[((vb)->vb_roffset + (r)) % VTBUF_MAX_HEIGHT(vb)][(c)]);
+    }
+}
+#endif
#+end_src


The kernel modifications are mostly under ~sys/dev/vt~ directory. To avoid cluttering the origin code, I created a additional directory called ~ime~ to store my patches. Here is a list of static and non-static functions defined in ~ime/vt_ime.{c,h}~ 


Static functions:
+ ~static int vt_ime_send_message(struct vt_ime *vi, char *message, char *ret)~
+ ~static int vt_ime_send_char(struct vt_ime *vi, int ch, char *ret)~
+ ~static int vt_ime_delete(struct vt_ime *vi, char *ret)~
+ ~static int vt_ime_request_output(struct vt_ime *vi, char *ret)~
+ ~static int vt_ime_check_valid_char(struct vt_ime *vi, int ch)~
+ ~static int vt_ime_convert_utf8_byte(int *utf8_left, int *utf8_partial, unsigned char c)~
+ ~static void vt_ime_input(struct terminal *, const void *, size_t)~


Non-static functions:
+ ~int vt_ime_toggle_mode(struct vt_ime *vi)~
+ ~int vt_ime_is_enabled(struct vt_ime *vi)~
+ ~int vt_ime_process_char(struct terminal *terminal, struct vt_device *vd, struct vt_ime *vi, int ch)~
+ ~void vt_ime_draw_status_bar(struct vt_device *vd, char *status)~

*** ~vt_ime_send_message~
- Defined in: :: ~sys/dev/vt/ime/vt_ime.c~  
  + ~static int vt_ime_send_message(struct vt_ime *vi, char *message, char *ret)~
- Description: :: for communicating with the IME server with socket.
 
*** ~vt_ime_send_char~
- Defined in: :: ~sys/dev/vt/ime/vt_ime.c~
  + ~static int vt_ime_send_char(struct vt_ime *vi, int ch, char *ret)~
- Description: :: for sending a single char data with ~vt_ime_send_message~.
 
*** ~vt_ime_delete~
- Defined in: :: ~sys/dev/vt/ime/vt_ime.c~
  + ~static int vt_ime_delete(struct vt_ime *vi, char *ret)~
- Description: :: for sending the string "delete" with ~vt_ime_send_message~ for performing the delete action.
 
*** ~vt_ime_request_output~
- Defined in: :: ~sys/dev/vt/ime/vt_ime.c~
  + ~static int vt_ime_request_output(struct vt_ime *vi, char *ret)~
- Description: :: for sending the string "output" with ~vt_ime_send_message~ for requesting the text that will be inserted.   
 
*** ~vt_ime_check_valid_char~
- Defined in: :: ~sys/dev/vt/ime/vt_ime.c~
  + ~static int vt_ime_check_valid_char(struct vt_ime *vi, int ch)~
- Description: :: for deciding which keys are required to be captured in the IME mode.

*** ~vt_ime_convert_utf8_byte~
- Defined in: :: ~sys/dev/vt/ime/vt_ime.c~
  + ~static int vt_ime_convert_utf8_byte(int *utf8_left, int *utf8_partial, unsigned char c)~
- Description: :: for converting a single utf8-encoded char sequence into a 32-bit unsigned integer (~term_char_t~).

*** ~vt_ime_input~
- Defined in: :: ~sys/dev/vt/ime/vt_ime.c~
  + ~static void vt_ime_input(struct terminal *term, const void *buf, size_t len)~
- Description: :: for inserting a utf8-encoded string ~buf~ with len ~len~ into the terminal with ~terminal_input_char~.

*** ~vt_ime_toggle_mode~
- Defined in: :: ~sys/dev/vt/ime/vt_ime.c~
  + ~int vt_ime_toggle_mode(struct vt_ime *vi)~
- Description: :: for toggling the IME mode. 
  
*** ~vt_ime_is_enabled~
- Defined in: :: ~sys/dev/vt/ime/vt_ime.c~
  + ~int vt_ime_is_enabled(struct vt_ime *vi)~
- Description: :: for checking if the IME mode is enabled. 

*** ~vt_ime_process_char~
- Defined in: :: ~sys/dev/vt/ime/vt_ime.c~
  + ~int vt_ime_process_char(struct terminal *terminal, struct vt_device *vd, struct vt_ime *vi, int ch)~
- Description: :: for processing chars and performing different actions.    

*** ~vt_ime_draw_status_bar~
- Defined in: :: ~sys/dev/vt/ime/vt_ime.c~
  + ~void vt_ime_draw_status_bar(struct vt_device *vd, char *status)~
    
- Description: :: for drawing the IME status on the screen     
  
* Conclusion 
